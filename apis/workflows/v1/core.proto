// Core types for workflows.

edition = "2023";

package workflows.v1;

import "buf/validate/validate.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "tilebox/v1/id.proto";

option features.field_presence = IMPLICIT;

// A cluster is a grouping of tasks that are related.
message Cluster {
  // 1 is reserved for a potential id field in the future.

  // The unique slug of the cluster within the namespace.
  string slug = 2;
  // The display name of the cluster.
  string display_name = 3;
  // Where the cluster is deletable
  bool deletable = 4;
}

// A job is a logical grouping of tasks that are related.
message Job {
  tilebox.v1.ID id = 1;
  string name = 2;
  string trace_parent = 3;
  reserved 4;
  // Whether the job has been canceled. Deprecated, part of the job status.
  bool canceled = 5 [deprecated = true];
  // The current state of the job. Deprecated, use status instead.
  LegacyJobState legacy_state = 6 [deprecated = true];
  // The time the job was submitted.
  google.protobuf.Timestamp submitted_at = 7;
  // The time the job started running. Deprecated, use execution_stats.first_task_started_at instead.
  google.protobuf.Timestamp started_at = 8 [deprecated = true];
  // A list of tasks of the job.
  repeated TaskSummary task_summaries = 9;
  // The automation that submitted the job.
  tilebox.v1.ID automation_id = 10;
  // A list of progress indicators for the job.
  repeated Progress progress = 11;
  // The status of the job.
  JobState state = 12;
  // The execution stats of the job inferred from the tasks.
  ExecutionStats execution_stats = 13;
}

// ExecutionStats contains statistics about the execution of a job.
message ExecutionStats {
  // The time the first task of the job was started.
  google.protobuf.Timestamp first_task_started_at = 1;
  // The time the last task of the job was stopped.
  google.protobuf.Timestamp last_task_stopped_at = 2;
  // The total compute time of the job, as sum of all task compute times.
  google.protobuf.Duration compute_time = 3;
  // The elapsed time of the job (wall time), which is the time from first task started to last task stopped.
  google.protobuf.Duration elapsed_time = 4;
  // The parallelism factor of the job, which is the average number of tasks running at any given time.
  double parallelism = 5;
  // Total number of tasks of the job.
  uint64 total_tasks = 6;
  // Number of tasks by their state.
  repeated TaskStateCount tasks_by_state = 7;
}

// TaskStateCount is a message specifying the number of tasks in a certain state.
message TaskStateCount {
  TaskState state = 1;
  uint64 count = 2;
}

// The state of a job, deprecated in favor of JobState.
enum LegacyJobState {
  LEGACY_JOB_STATE_UNSPECIFIED = 0;
  // The job is queued and waiting to be run.
  LEGACY_JOB_STATE_QUEUED = 1;
  // At least one task of the job has been started.
  LEGACY_JOB_STATE_STARTED = 2;
  // All tasks of the job have been completed.
  LEGACY_JOB_STATE_COMPLETED = 3;
}

// The state of a job, which is computed from the state of each of the jobs tasks combined with the information
// if the job has been canceled or not.
enum JobState {
  JOB_STATE_UNSPECIFIED = 0;
  // The job has been submitted, queued and waiting for its first task to be run.
  JOB_STATE_SUBMITTED = 1;
  // The job is running, i.e. at least one task is running.
  JOB_STATE_RUNNING = 2;
  // The job has started running, i.e. at least one task has been computed, but currently no tasks are running.
  JOB_STATE_STARTED = 3;
  // The job has completed successfully.
  JOB_STATE_COMPLETED = 4;
  // The job has failed.
  JOB_STATE_FAILED = 5;
  // The job has been canceled on user request.
  JOB_STATE_CANCELED = 6;
}

// A summary of a task. Mainly used in the Console.
message TaskSummary {
  tilebox.v1.ID id = 1;
  string display = 2;
  TaskState state = 3;
  tilebox.v1.ID parent_id = 4;
  reserved 5; // depends_on in case we want to add that in the future
  google.protobuf.Timestamp started_at = 6;
  google.protobuf.Timestamp stopped_at = 7;
}

// Progress is an indicator of total and completed work units for a job.
message Progress {
  // A human-readable label for the progress indicator. Can also be empty.
  string label = 1 [(buf.validate.field).string.max_len = 100];
  // The total number of work units to be processed.
  uint64 total = 2;
  // The number of work units that have already been processed.
  uint64 done = 3;
}

// A task is a single unit of work.
message Task {
  // The id of the task instance. Contains the submission timestamp as the time part of the ULID.
  tilebox.v1.ID id = 1;
  // Unique identifier for the task. Used by runners to match tasks to specific functions.
  TaskIdentifier identifier = 2;
  // The current state of the task.
  TaskState state = 3;
  // The serialized input parameters for the task in the format that this task expects.
  bytes input = 4 [features.field_presence = EXPLICIT];
  // Display is a human readable representation of the Task used for printing or visualizations
  string display = 5 [features.field_presence = EXPLICIT];
  // The job that this task belongs to.
  Job job = 6;
  // The id of the parent task.
  tilebox.v1.ID parent_id = 7;
  // The ids of the tasks that this task depends on.
  repeated tilebox.v1.ID depends_on = 8;
  // The lease of the task.
  TaskLease lease = 9;
  // The number of times this task has been retried.
  int64 retry_count = 10;
}

// The state of a task.
enum TaskState {
  TASK_STATE_UNSPECIFIED = 0;
  // The task is queued and waiting to be run.
  TASK_STATE_QUEUED = 1;
  // The task is currently running on some task runner.
  TASK_STATE_RUNNING = 2;
  // The task has been computed and the output is available.
  // If the task also has no more outstanding children, it is considered COMPLETED.
  TASK_STATE_COMPUTED = 3;
  // The task has failed.
  TASK_STATE_FAILED = 4;
}

// An identifier for a task.
message TaskIdentifier {
  // A unique name of a task (unique within a namespace).
  string name = 1 [(buf.validate.field).string = {
    min_bytes: 1
    max_bytes: 256
  }];
  // Version of the task.
  string version = 2 [(buf.validate.field).string = {
    min_bytes: 1
    pattern: "^v(\\d+)\\.(\\d+)$"
  }];
}

// A list of tasks.
message Tasks {
  repeated Task tasks = 1;
}

// TaskSubmission is a message of a task that is just about to be submitted, either by submitting a job or as a subtask.
message TaskSubmission {
  // The cluster that this task should be run on
  string cluster_slug = 1;
  // The task identifier
  TaskIdentifier identifier = 2;
  // A human-readable description of the task
  string display = 4 [(buf.validate.field).string.min_len = 1];
  // A list of indices, corresponding to tasks in the list of sub_tasks that this SubTask is part of.
  repeated int64 dependencies = 5 [(buf.validate.field).repeated.items.int64 = {
    gte: 0
    lte: 63
  }];
  // The maximum number of retries for this task.
  int64 max_retries = 6 [(buf.validate.field).int64.gte = 0];

  // The serialized task instance, if there is only a single instance.
  bytes input = 3 [(buf.validate.field).bytes.max_len = 2048];
}

// TaskSubmissions is a structure for representing a set of tasks about to be submitted, either as a job or as subtasks.
// It is optimized for efficient serialization for cases where a large number of very similar tasks are submitted,
// with potentially only the individual input parameters varying.
// To reduce the serialization size, we keep a separate list/lookup table of unique task properties, that can then be
// referenced by their index.
message TaskSubmissions {
  // Concrete instantiations of tasks, grouped by their dependencies and dependants, and referencing entries in the
  // lookup tables also contained in this message by index.
  repeated TaskSubmissionGroup task_groups = 1;
  // Unique values of cluster slugs, referenced by index in the task instantiations.
  repeated string cluster_slug_lookup = 2;
  // Unique values of task identifiers, referenced by index in the task instantiations.
  repeated TaskIdentifier identifier_lookup = 3;
  // Unique values of display names, referenced by index in the task instantiations.
  repeated string display_lookup = 4 [(buf.validate.field).repeated.items.string.min_len = 1];
}

// TaskSubmissionGroup is a structure for representing a list of submitted tasks, that all share the exact same
// dependencies and dependants. Grouping tasks by their dependency edges, and then converting task dependencies to
// group dependencies can help to drastically reduce the number of edges we need to serialize and transmit.
// Dependants are not explicitly specified, since they can be inferred from the dependencies of the other groups
// in the containing TaskSubmissions message. This means that the `dependencies_on_other_groups` field is not unique,
// across groups, since there may be two groups sharing the same dependencies but having different dependants.
message TaskSubmissionGroup {
  option (buf.validate.message).cel = {
    id: "task_submission_group.task_fields_size_match"
    message: "The length of the task related fields must match."
    expression: "this.inputs.size() == this.max_retries.size() && this.inputs.size() == this.identifier.size() && this.inputs.size() == this.cluster_slug.size() && this.inputs.size() == this.display.size() && this.inputs.size() == this.max_retries.size()"
  };

  // The indices of the groups that this submission group depends on. Indices refer to the groups field of the
  // containing TaskSubmissions message.
  repeated uint32 dependencies_on_other_groups = 1;
  // The input parameters for each task.
  // We explicitly don't group the fields into a submessage and then have a single repeated field for that submessage,
  // to enable packed encoding of the repeated fields.
  repeated bytes inputs = 2 [(buf.validate.field).repeated.items.bytes.max_len = 2048];
  // Index of the task identifier in the identifier_lookup field of the containing TaskSubmissions message
  // for each task.
  repeated uint64 identifier = 3;
  // Index of the cluster slug in the cluster_slug_lookup field of the containing TaskSubmissions message for each task,
  // indicating the cluster that the task should be run on.
  repeated uint64 cluster_slug = 4;
  // Index of the display name in the display_lookup field of the containing TaskSubmissions message for each task,
  // specifying a human-readable description of the task.
  repeated uint64 display = 5;
  // The maximum number of retries for each task. Not a pointer to a lookup table, since we just inline the values.
  repeated int64 max_retries = 6;
}

// A lease for a task.
message TaskLease {
  google.protobuf.Duration lease = 1;
  google.protobuf.Duration recommended_wait_until_next_extension = 2;
}
